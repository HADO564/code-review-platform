package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.49

import (
	"backend/database"
	"backend/graph/model"
	"context"
	"fmt"
	"time"

	"github.com/google/uuid"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, input model.NewUser) (*model.User, error) {
	client:= database.GetClient()

	newuser := &model.User{
		ID: uuid.New().String(),
		Username: input.Username,
		Email: input.Email,
		CreatedAt: time.Now().String(), 
		UpdatedAt: time.Now().String(),
		Projects: []*model.Project{},
		Reviews: []*model.Review{},
	}

	usertoinsert := map[string]interface{}{
		"id": newuser.ID,
		"username": newuser.Username,
		"email": newuser.Email,
		"createdAt": newuser.CreatedAt,
		"updatedAt": newuser.UpdatedAt,
	}

	_, _, err := client.From("users").Insert(usertoinsert,false,"","minimal","exact").Execute()
	if err != nil {
		return nil, err
	}	
	r.users = append(r.users, newuser)
	return newuser, nil
}

// CreateProject is the resolver for the createProject field.
func (r *mutationResolver) CreateProject(ctx context.Context, input model.NewProject) (*model.Project, error) {
	client := database.GetClient()
	
	var myuser *model.User
	for _, user := range r.users {
		if user.ID == input.OwnerID {
			myuser = user
		}
	}
	if myuser == nil {
		return nil, fmt.Errorf("User not found")
	}		
	
	newproj := &model.Project{
		ID: uuid.New().String(),     
		Name: input.Name,         
		Description: input.Description,   
		Owner: myuser,       
		CodeSnippets: []*model.CodeSnippet{},  
		Collaborators: []*model.ProjectCollaborator{},
		CreatedAt: time.Now().String(),
		UpdatedAt: time.Now().String(),
	}

	projtoinsert := map[string]interface{}{
		"id": newproj.ID,
		"name": newproj.Name,
		"description": newproj.Description,
		"ownerId": input.OwnerID,
		"createdAt": newproj.CreatedAt,
		"updatedAt": newproj.UpdatedAt,
	}

	_, _, err := client.From("projects").Insert(projtoinsert,false,"","minimal","exact").Execute()
	if err != nil {
		return nil, err
	}

	r.projects = append(r.projects, newproj)
	return newproj, nil
}

// CreateCodeSnippet is the resolver for the createCodeSnippet field.
func (r *mutationResolver) CreateCodeSnippet(ctx context.Context, input model.NewCodeSnippet) (*model.CodeSnippet, error) {
	client := database.GetClient()
	
	var myuser *model.User
	for _, user := range r.users {
		if user.ID == input.CreatedByID {
			myuser = user
		}
	}
	if myuser == nil {
		return nil, fmt.Errorf("User not found")
	}

	var myproj *model.Project
	for _, proj := range r.projects {
		if proj.ID == input.ProjectID {
			myproj = proj
		}
	}
	if myproj == nil {
		return nil, fmt.Errorf("Project not found")
	}
	
	newsnippet := &model.CodeSnippet{
		ID: uuid.New().String(),
		Project: myproj,	
		Title: input.Title,
		Content: input.Content,
		Language: input.Language,
		Version: 1,
		CreatedBy: myuser,
		Reviews: []*model.Review{},
		CreatedAt: time.Now().String(),
		UpdatedAt: time.Now().String(),
	}

	snippettoinsert := map[string]interface{}{
		"id": newsnippet.ID,
		"projectId": input.ProjectID,
		"title": newsnippet.Title,
		"content": newsnippet.Content,
		"language": newsnippet.Language,
		"version": newsnippet.Version,
		"createdBy": input.CreatedByID,
		"createdAt": newsnippet.CreatedAt,
		"updatedAt": newsnippet.UpdatedAt,
	}

	_, _, err := client.From("codeSnippets").Insert(snippettoinsert,false,"","minimal","exact").Execute()
	if err != nil {
		return nil, err
	}

	r.codeSnippets = append(r.codeSnippets, newsnippet)
	return newsnippet, nil
}

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, input model.NewReview) (*model.Review, error) {
	client := database.GetClient()
	
	var myuser *model.User
	for _, user := range r.users {
		if user.ID == input.ReviewerID {
			myuser = user
		}
	}
	if myuser == nil {
		return nil, fmt.Errorf("User not found")
	}

	var mysnippet *model.CodeSnippet
	for _, snippet := range r.codeSnippets {
		if snippet.ID == input.SnippetID {
			mysnippet = snippet
		}
	}
	if mysnippet == nil {
		return nil, fmt.Errorf("CodeSnippet not found")
	}
	
	newreview := &model.Review{
		ID: uuid.New().String(),
		Snippet: mysnippet,
		Status: model.ReviewStatusPending,
		Reviewer: myuser,
		Comments: []*model.Comment{},
		CreatedAt: time.Now().String(),
		UpdatedAt: time.Now().String(),
	}

	reviewtoinsert := map[string]interface{}{
		"id": newreview.ID,
		"snippetId": input.SnippetID,
		"reviewerId": input.ReviewerID,
		"createdAt": newreview.CreatedAt,
		"updatedAt": newreview.UpdatedAt,
		"status": newreview.Status.String(),
	}

	_, _, err := client.From("reviews").Insert(reviewtoinsert,false,"","minimal","exact").Execute()
	if err != nil {
		return nil, err
	}
	r.reviews = append(r.reviews, newreview)
	return newreview, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, input model.NewComment) (*model.Comment, error) {
	client := database.GetClient()
	
	var myuser *model.User
	for _, user := range r.users {
		if user.ID == input.UserID {
			myuser = user
		}
	}
	if myuser == nil {
		return nil, fmt.Errorf("User not found")
	}
	
	var myreview *model.Review
	for _, review := range r.reviews {
		if review.ID == input.ReviewID {
			myreview = review
		}
	}
	if myreview == nil {
		return nil, fmt.Errorf("Review not found")
	}
	
	newcomment := &model.Comment{
		ID: uuid.New().String(),
		Review: myreview,
		User: myuser,
		Content: input.Content,
		LineNumber: input.LineNumber,
		CreatedAt: time.Now().String(),
		UpdatedAt: time.Now().String(),
	}

	commenttoinsert := map[string]interface{}{
		"id": newcomment.ID,
		"reviewId": input.ReviewID,
		"userId": input.UserID,
		"content": newcomment.Content,
		"lineNumber": newcomment.LineNumber,
		"createdAt": newcomment.CreatedAt,
		"updatedAt": newcomment.UpdatedAt,
	}

	_, _, err := client.From("comments").Insert(commenttoinsert,false,"","minimal","exact").Execute()
	if err != nil {
		return nil, err
	}

	r.comments = append(r.comments, newcomment)
	return newcomment, nil
}

// AddProjectCollaborator is the resolver for the addProjectCollaborator field.
func (r *mutationResolver) AddProjectCollaborator(ctx context.Context, input model.NewProjectCollaborator) (*model.ProjectCollaborator, error) {
	client := database.GetClient()
	
	var myuser *model.User
	for _, user := range r.users {
		if user.ID == input.UserID {
			myuser = user
		}
	}
	if myuser == nil {
		return nil, fmt.Errorf("User not found")
	}

	var myproj *model.Project
	for _, proj := range r.projects {
		if proj.ID == input.ProjectID {
			myproj = proj
		}
	}
	if myproj == nil {
		return nil, fmt.Errorf("Project not found")
	}
	
	newcollab := &model.ProjectCollaborator{
		Project: myproj,
		User: myuser,
		Role: input.Role,
	}

	collabtoinsert := map[string]interface{}{
		"projectId": input.ProjectID,
		"userId": input.UserID,
		"role": input.Role.String(),
	}

	_, _, err := client.From("collaborators").Insert(collabtoinsert,false,"","minimal","exact").Execute()
	if err != nil {
		return nil, err
	}

	r.collabs = append(r.collabs, newcollab)
	return newcollab, nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	for _, user := range r.users {
		if user.ID == id {
			return user, nil
		}
	}
	return nil, fmt.Errorf("User not found")
}

// Project is the resolver for the project field.
func (r *queryResolver) Project(ctx context.Context, id string) (*model.Project, error) {
	for _, proj := range r.projects {
		if proj.ID == id {
			return proj, nil
		}
	}
	return nil, fmt.Errorf("Project not found")
}

// CodeSnippet is the resolver for the codeSnippet field.
func (r *queryResolver) CodeSnippet(ctx context.Context, id string) (*model.CodeSnippet, error) {
	for _, snippet := range r.codeSnippets {
		if snippet.ID == id {
			return snippet, nil
		}
	}
	return nil, fmt.Errorf("CodeSnippet not found")
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context, id string) (*model.Review, error) {
	for _, review := range r.reviews {
		if review.ID == id {
			return review, nil
		}
	}
	return nil, fmt.Errorf("Review not found")
}

// Comment is the resolver for the comment field.
func (r *queryResolver) Comment(ctx context.Context, id string) (*model.Comment, error) {
	for _, comment := range r.comments {
		if comment.ID == id {
			return comment, nil
		}
	}
	return nil, fmt.Errorf("Comment not found")
}

// ProjectCollaborator is the resolver for the projectCollaborator field.
func (r *queryResolver) ProjectCollaborator(ctx context.Context, projectID string, userID string) (*model.ProjectCollaborator, error) {
	for _, collab := range r.collabs {
		if collab.Project.ID == projectID && collab.User.ID == userID {
			return collab, nil
		}
	}
	return nil, fmt.Errorf("ProjectCollaborator not found")
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//   - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//     it when you're done.
//   - You have helper methods in this file. Move them out to keep these resolver files clean.
